
const { RestClientV5 } = require("bybit-api"); // –û–±–Ω–æ–≤–ª–µ–Ω–æ
const { json } = require("express");
const WebSocket = require("ws");


class BybitService {
  _pool = new Map();

  orders = new Map();
  prices = {};
  symbols;
  promisePrices = new Map();

  wsTickers = new Set();
  ws;
// –ö–æ–¥ –¥–ª—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –≤–µ–±-—Å–æ–∫–µ—Ç–∞–º Bybit
  async load() {
    this.ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");
//–¥–æ–∂–∏–¥–∞–µ–º—Å—è –æ—Ç–∫—Ä—ã—Ç–∏–µ —Å–æ–∫–µ—Ç–∞

    await new Promise(
      (resolve)=>this.ws.on("open",()=>{
        console.log("Bybit: Public Websocket open");
        
        resolve();
    }));

    this.ws.onmessage = (event) => {

        const data = JSON.parse(event.data);//–¥–∞–Ω–Ω—ã–µ, –ø–æ–ª—É—á–µ–Ω–Ω—ã–µ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ –¥–µ–ª–∞–µ—Ç –æ–±—ä–µ–∫—Ç
        console.log("–î–ê–¢–ê", data)
        this.onWSData(data);
    };

   

    this.ws.onclose = async () => {
      console.info("Bybit: Connection closed.");

      await this.load();

      this.wsTickers.forEach((ticker) => {
        this.ws.send(
          JSON.stringify({ op: "unsubscribe", args: [`publicTrade.${ticker}`] })
        );
      });
    };

    this.ws.onerror = () => console.info("Bybit: Connection error.");
  }
// –ö–æ–¥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞ —Ç–æ—Ä–≥–∏ –ø–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º—É —Ç–∏–∫–µ—Ä—É
  listTicker(ticker) {
    if (this.wsTickers.has(ticker)) return;
    console.log("subscribe on",ticker);
    this.wsTickers.add(ticker);
    this.ws.send(
      JSON.stringify({ op: "subscribe", args: [`publicTrade.${ticker}`] })
    );
  }
// –ö–æ–¥ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –ø–æ–ª—É—á–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –æ —Ç–æ—Ä–≥–∞—Ö

  onWSData(data) {
    if (!data){ return console.log("onWSData –Ω–µ—Ç –¥–∞—Ç—ã!")};

      //console.log("----------------------------------–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω—ã----------------------------------------------------");
      
      let entries = Object.entries(data)
      let newEnt = entries[3];
      let ki = Object.values(newEnt);
      let objectDataWhereTickers = JSON.stringify(ki);


      let resprice = objectDataWhereTickers.substring(objectDataWhereTickers.lastIndexOf('"p":"')+5);
      let lastprice = resprice.split('"')[0];
      const price = parseFloat(lastprice);
      

      let restick = objectDataWhereTickers.substring(objectDataWhereTickers.lastIndexOf('"s":"')+5);
      let ticker = restick.split('"')[0]
      
      

      //console.log("ki",objectDataWhereTickers);

    if(price){this.onMarkPrice({ ticker, price })}
      
    }


 // –ö–æ–¥ –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ —Ä–∞–∑–º–µ—â–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞

  async onOpenOrder(req, res) {
  console.log("======================================ONOPENORDER========================================")

//–±–∞–¥–∏ –Ω–∞—à–µ–≥–æ –∑–∞–ø—Ä–æ—Å–∞
    const data = req.body;
    
//side - –ø–æ–∫—É–ø–∫–∞ –∏–ª–∏ –ø—Ä–æ–¥–∞–∂–∞
//ticker - —Ç–æ—Ä–≥–æ–≤–∞—è –ø–∞—Ä–∞
    const { ticker, takeProfits, stopLoss, side } = data;
    
    console.log(`Side: ${side}`);
    this.listTicker(ticker);
   
    const clients = DatabaseService.all();//—Å–ø–∏—Å–æ–∫ –∫–ª–∏–µ–Ω—Ç–æ–≤
    data.clients = new Set();//—Ö—Ä–∞–Ω–µ–Ω–∏–µ


    
        for await (const e of Object.values(clients)) {
      //const e = clients[i];
      console.log(e);

      if (e.exchange !== 1 || !e.bybit || !e.trading) continue;

      const client = await this.createSocket(
        e.bybit.publicKey,
        e.bybit.privateKey,
        e.bybit.isInverse
      );

      console.log(`Get client: ${!!client}`);

      if (!client) continue;

      const positions = await client.getPositionInfo({
        symbol: `${ticker}`,
        category: "linear",
        settleCoin: "USDT",
      });
      console.log("positions-------", positions);
      console.log("positionsreslist-------", positions.result.list);
      let getpos = (!positions || !Array.isArray(positions));

      console.log(`Get positions : ${getpos}`);

      if (getpos) {
        continue;
      }

      if (!e.maxPositions) {
        e.maxPositions = 5;
      }

      const activePositions = positions.reduce(
        (a, b) => a + (b.size !== 0 ? 1 : 0),
        0
      );

      console.log(
        `Is active positions max ${i}: ${activePositions >= e.maxPositions}`
      );

      if (activePositions >= e.maxPositions) {
        continue;
      }

      const balance = (await client.getWalletBalance({ coin: "USDT" })).result
        .USDT.available_balance;

      if (!e.capitalPercent) {
        e.capitalPercent = 5;
      }

      if (!e.leverage) {
        e.leverage = 15;
      }
  
      const tickerData = this.symbols.find((e) => e.symbol === ticker);

      const price = tickerData.lastPrice;

      let quantity = parseFloat(
        (((balance * (e.capitalPercent / 100)) / price) * e.leverage).toFixed(
          tickerData.price_filter.tick_size.split(".")[1].length
        )
      );

      if (quantity < tickerData.lot_size_filter.min_trading_qty)
        quantity = tickerData.lot_size_filter.min_trading_qty;
      if (quantity > tickerData.lot_size_filter.max_trading_qty)
        quantity = tickerData.lot_size_filter.max_trading_qty;
      await this.closePosition(client, positions, ticker);

      const leverage = e.bybit.isInverse ? 1 / e.leverage : e.leverage; // –ò–∑–º–µ–Ω–µ–Ω–æ

      const res = await client.submitOrder({
        side: side ? "Buy" : "Sell",
        category: "linear",
        symbol: ticker,
        orderType: "Market",
        qty: quantity,
        timeInForce: "FillOrKill",
        reduceOnly: false,
        closeOnTrigger: false,
        positionIdx: 0,
      });
//??????????????????????????????????????????????????????????????????????????????????????????
      console.log("Open position", res);

      data.clients.add([e.bybit.publicKey, e.bybit.privateKey, leverage]);

      await TelegramService.bot.sendMessage(
        parseInt(i),
        res && res.ret_code === 0
          ? `‚òë *NEW POSITION OPENED* ‚òë\n‚ñ™ *Ticker:* \`${
              data.ticker
            }\` \n‚ñ™ *Direction:* \`${
              data.side ? "Long" : "Short"
            }\`\n‚ñ™ *Entry:* \`${price}\`\n‚ñ™ *Amount:* \`${quantity} ${ticker.replace(
              "USDT",
              ""
            )}\`\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\nü§ñThe bot will *automatically open and close* this signal, please do not close this trade manually!`
          : `Some error when tried open ${data.ticker}`,
        {
          parse_mode: "markdown",
        }
      );
    }
    data.takeProfitsSize = data.takeProfits.length;
    data.entryPrice = price;

    this.orders.set(data.ticker, data);

    res.send("OK");
    
    let price = this.prices[ticker];//—Ç–µ–∫—É—â–∞—è —Ü–µ–Ω–∞ —Ç–æ—Ä–≥–æ–≤–æ–π –ø–∞—Ä—ã
    console.log(price)
    if (typeof price !== "number") price = await this.getPrice(ticker);
    console.log(`Get price ${ticker}: ${price}`);



  }

  async onStopLossChange({ ticker, stopLoss }, res) {
    const order = this.orders.get(ticker);

    if (!order) return;

    order.stopLoss = stopLoss;

    this.orders.set(ticker, order);

    res.send("OK");
  }

  async onPositionExit({ ticker }, res) {
    const order = this.orders.get(ticker);

    if (!order) return res.send("ORDER DONT FOUND");

    let percentProfit = order.entryPrice / this.prices[ticker];

    if (percentProfit < 0) percentProfit = 1 - percentProfit + 1;

    for (const [publicKey, privateKey, leverage] of order.clients) {
      try {
        const client = await this.createSocket(publicKey, privateKey);
        const positions = (
          await client.getPositionInfo({
            category: "linear",
            settleCoin: "USDT",
          })
        ).result;

        if (!positions || !Array.isArray(positions)) {
          continue;
        }

        await this.closePosition(client, positions, ticker);

        const chatId = TelegramService.bybitPublicKeyId.get(publicKey);
        const profit = ((percentProfit - 1) * leverage * 100).toFixed(2);
        const dbData = DatabaseService.get(chatId);

        if (typeof dbData.pnl !== "number") {
          dbData.pnl = 0;
        }

        const profitPnl = Math.abs((percentProfit - 1) * leverage * 100);

        dbData.pnl += profitPnl;

        DatabaseService.set(chatId, dbData);

        await TelegramService.bot.sendMessage(
          chatId,
          `üí∞*SIGNAL CLOSED*üí∞\n‚ñ™ *Ticker*: \`${
            order.ticker
          }\`\n‚ñ™ *Direction*: ${
            order.side ? "Long" : "Short"
          }\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\nüîπ Targets reached: ${
            order.takeProfitsSize - order.takeProfits.length
          }\nüîπ Profit: +${profit}%`,
          {
            parse_mode: "markdown",
          }
        );
      } catch (e) {
        if (!e.message) e.message = e.body;

        console.log(
          `Some error when try exit position (Client: ${publicKey}): `,
          e.message
        );
      }
    }

    this.orders.delete(ticker);

    res.send("OK");
  }
//–Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ü–µ–Ω—ã –¥–ª—è —Ç–∏–∫–µ—Ä–∞
  async onMarkPrice({ ticker, price }) {
    console.log("-------------------------------------------- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω—ã –≤ —Å–ø–∏—Å–∫–µ--------------------------------------------");
    console.log(`ticker: ${ticker} + price: ${price}`);
    //–ü—Ä–æ–≤–µ—Ä–∫–∞ –µ—Å—Ç—å –ª–∏ –æ–±–µ—â–∞–Ω–∏—è –ø–æ —Ü–µ–Ω–µ, –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–æ –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è —Ç–∏–∫–µ—Ä –∏ –ø—Ä–∞–π—Å
    if (this.promisePrices.has(ticker)){this.promisePrices.get(ticker)(price)} ;
//–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ü–µ–Ω—ã –≤ —Å–ø–∏—Å–∫–µ
    this.prices[ticker] = price;
    //console.log("prices",prices)
    const order = this.orders.get(ticker);
    console.log("order",order)
//–µ—Å–ª–∏ –æ—Ä–¥–µ—Ä–∞ –Ω–µ—Ç —Ç–æ –¥—Ä–æ–ø
    if (!order) return console.log("orderanet");
//–∑–∞–±–∏—Ä–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–∫–µ—Ä–∞

    if (!this.symbols) {
        console.log("–Ω–µ—Ç –º–∞—Å—Å–∏–≤–∞ symbols")
        this.symbols = await client.getTickers({
          category: "linear",
          settleCoin: "USDT",
        });

        console.log("symbols", this.symbols)
      }

    const tickerData = this.symbols.find((e) => e.name === ticker);
    //console.log("!_!_!_!_!__!!_!_!_!",tickerData)

// "symbol":"1000000VINUUSDT","lastPrice":"0.015558","indexPrice":"0.015519","markPrice":"0.015525","prevPrice24h":"0.014410",
// "price24hPcnt":"0.079666","highPrice24h":"0.015558","lowPrice24h":"0.014171","prevPrice1h":"0.015357","openInterest":"3507100",
// "openInterestValue":"54447.73","turnover24h":"2333592.0814","volume24h":"159101900.0000","fundingRate":"0.00007872",
// "nextFundingTime":"1706428800000","predictedDeliveryPrice":"","basisRate":"","deliveryFeeRate":"","deliveryTime":"0","ask1Size":"887800",
// "bid1Price":"0.015461","ask1Price":"0.015558","bid1Size":"874400","basis":""

/*[{"symbol":"1000LUNCUSDT","leverage":"10","autoAddMargin":0,"avgPrice":"","liqPrice":"","riskLimitValue":"100000","takeProfit":"",
"positionValue":"","tpslMode":"","isReduceOnly":false,"riskId":1,"trailingStop":"","unrealisedPnl":"","markPrice":"","adlRankIndicator":0,
"cumRealisedPnl":"","positionMM":"","createdTime":"","positionIdx":0,"positionIM":"","seq":-1,"updatedTime":"","side":"","bustPrice":"",
"positionBalance":"","leverageSysUpdatedTime":"","size":"0","positionStatus":"","mmrSysUpdatedTime":"","stopLoss":"","tradeMode":0}]*/


    let takeProfitReached = false;
    let lastTakeProfit;
    let stopLoss = false;

    if (order.side && price <= order.stopLoss) {
      stopLoss = true;
    } else if (!order.side && price >= order.stopLoss) {
      stopLoss = true;
    }

    if (stopLoss) {
      this.orders.delete(ticker);
    } else {
      for (const take of order.takeProfits) {
        if (order.side && price >= take[0]) {
          takeProfitReached = true;
        }

        if (!order.side && price <= take[0]) {
          takeProfitReached = true;
        }

        if (takeProfitReached) {
          lastTakeProfit = take;
          order.takeProfits.splice(order.takeProfits.indexOf(take), 1);

          if (order.takeProfits.length === 0) {
            this.orders.delete(ticker);
          }

          break;
        }
      }
    }
//--------------------------------------------------------------------------------
    for (const [publicKey, privateKey, leverage] of order.clients) {
      if (takeProfitReached) {
        const chatId = TelegramService.bybitPublicKeyId.get(publicKey);
        let dbData = DatabaseService.get(chatId);

        if (!dbData.strategy) dbData.strategy = -1;

        if (
          dbData.strategy !== -1 &&
          dbData.strategy !== order.takeProfitsSize - order.takeProfits.length
        ) {
          continue;
        }

        const client = await this.createSocket(publicKey, privateKey);
        const position = await this.getActivePosition(client, ticker);

        if (position) {
          let quantity = position.data.size;

          let qty = quantity * (lastTakeProfit[1] / 100);

          qty = parseFloat(
            qty.toFixed(tickerData.price_filter.tick_size.split(".")[1].length)
          );

          const isFullPos =
            dbData.strategy !== -1 &&
            dbData.strategy ===
              order.takeProfitsSize - order.takeProfits.length;

          if (quantity < qty || order.takeProfits.length === 0 || isFullPos) {
            qty = quantity;
          }

          const result = await client.submitOrder({
            side: !order.side ? "Buy" : "Sell",
            symbol: ticker,
            order_type: "Market",
            qty,
            time_in_force: "FillOrKill",
            reduce_only: false,
            close_on_trigger: true,
            position_idx: 0,
          });

          console.log(
            "TAKEPROFIT CHATID" + chatId,
            order.takeProfitsSize - order.takeProfits.length,
            isFullPos,
            result
          );

          if (order.takeProfits.length === 0 || isFullPos) {
            let percentProfit = order.entryPrice / price;

            if (percentProfit < 0) percentProfit = 1 - percentProfit + 1;

            if (typeof dbData.pnl !== "number") {
              dbData.pnl = 0;
            }

            const profitPnl = Math.abs((percentProfit - 1) * leverage * 100);

            dbData.pnl += profitPnl;

            DatabaseService.set(chatId, dbData);

            await TelegramService.bot.sendMessage(
              chatId,
              `üí∞*SIGNAL CLOSED*üí∞\n‚ñ™ *Ticker*: \`${
                order.ticker
              }\`\n‚ñ™ *Direction*: ${
                order.side ? "Long" : "Short"
              }\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\nüîπ Targets reached: ${
                order.takeProfitsSize - order.takeProfits.length
              }\nüîπ Profit: +${profitPnl.toFixed(2)}%`,
              {
                parse_mode: "markdown",
              }
            );
          }
        }

        continue;
      }

      if (stopLoss) {
        const client = await this.createSocket(publicKey, privateKey);
        const position = await this.getActivePosition(client, ticker);

        if (position) {
          const result = await client.submitOrder({
            side: !order.side ? "Buy" : "Sell",
            symbol: ticker,
            order_type: "Market",
            qty: position.data.size,
            time_in_force: "FillOrKill",
            reduce_only: false,
            close_on_trigger: false,
            position_idx: 0,
          });

          let percentLoss = order.entryPrice / price;

          if (percentLoss < 0) percentLoss = 1 - percentLoss + 1;

          const chatId = TelegramService.bybitPublicKeyId.get(publicKey);
          let dbData = DatabaseService.get(chatId);

          if (typeof dbData.pnl !== "number") {
            dbData.pnl = 0;
          }

          if (order.takeProfitsSize - order.takeProfits.length < 2) {
            const profit = Math.abs((percentLoss - 1) * leverage * 100);

            dbData.pnl -= profit;

            await TelegramService.bot.sendMessage(
              chatId,
              `ü©∏*STOP LOSS HIT*ü©∏\n‚ñ™ *Ticker:* \`${
                order.ticker
              }\`\n‚ñ™ *Direction:* \`${
                order.side ? "Long" : "Short"
              }\`\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\nüîªLoss: -${profit.toFixed(2)}%`,
              {
                parse_mode: "markdown",
              }
            );
          } else {
            const profit = Math.abs((percentLoss - 1) * leverage * 100);

            dbData.pnl += profit;

            await TelegramService.bot.sendMessage(
              chatId,
              `üí∞*SIGNAL CLOSED*üí∞\n‚ñ™ *Ticker*: \`${
                order.ticker
              }\`\n‚ñ™ *Direction*: ${
                order.side ? "Long" : "Short"
              }\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\nüîπ Targets reached: ${
                order.takeProfitsSize - order.takeProfits.length
              }\nüîπ Profit: +${profit.toFixed(2)}%`,
              {
                parse_mode: "markdown",
              }
            );
          }

          DatabaseService.set(chatId, dbData);

          console.log("ByBit | StopLoss", result);
        }
      }
    }
  }

  async getActivePosition(client, ticker, positions = null) {
    if (!positions) {
      positions = (
        await client.getPositionInfo({
          symbol: `${ticker}`,
          category: "linear",
          settleCoin: "USDT",
        })
      ).result;

      if (!positions || !Array.isArray(positions)) {
        return null;
      }
    }

    const position = positions.find((e) => e.data.symbol === ticker);

    if (position) {
      const amt = position.data.size;

      if (typeof amt !== "number" || amt === 0) {
        return null;
      }

      return position;
    }

    return null;
  }

  async closePosition(client, positions, ticker) {
    const position = await this.getActivePosition(client, ticker, positions);

    if (!position) return;

    const result = await client.submitOrder({
      side: position.data.side === "Sell" ? "Buy" : "Sell",
      symbol: ticker,
      order_type: "Market",
      qty: position.data.size,
      time_in_force: "FillOrKill",
      reduce_only: false,
      close_on_trigger: false,
      position_idx: 0,
    });

    console.log("Close active position", result);
  }
//—Ü–µ–Ω–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ü–µ–Ω—ã –∞–∫—Ç–∏–≤–∞ 
  async getPrice(ticker) {
    console.log("--------------------------------getPrice-----------------------------------------")
    const price = await new Promise((r) => {
      this.promisePrices.set(ticker, r);//—É—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–Ω–∞—á–µ–Ω–∏—è r –¥–ª—è –∫–ª—é—á–∞ —Ç–∏–∫–µ—Ä
      console.log(price);
    });

    this.promisePrices.delete(ticker);

    return price;
  }

  async createSocket(key, secret, isInverse) {
    if (this._pool.has(key)) return this._pool.get(key);

    try {
      const client = new RestClientV5({
        key: key,
        secret: secret,
        // testnet
        testnet: true,

        enableTimeSync: true,
      });
      // testnet
      await client.getAccountInfo();

      this._pool.set(key, client);

      return client;
    } catch (e) {
      if (!e.message) e.message = e.body;
      console.log(e.message);
      return false;
    }
  }
//—Ü–µ–Ω–∞ —Ç–∏–∫–µ—Ä–∞
  async getTickerPrice(client, ticker) {
    return (await client.getTickers({ category: "linear", symbol: ticker }))
      .result.list[0].lastPrice;
  }
}

module.exports = new BybitService();

const client = new RestClientV5({
  key: "",
  secret: "",
  testnet: true,
  enableTimeSync: true,
});

const res4 = client
  .getTickers({category: "linear", settleCoin: "USDT" })
  .then((response) => console.log("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –ø–æ –≤—Å–µ–º —Ç–∏–∫–µ—Ä–∞–º: ",response.result.list));
// const balance = client
//   .getWalletBalance({
//     accountType: "UNIFIED",
//     coin: "USDT",
//   })
//   .then((data) =>
//     console.log("Balacne ---", data.result.list[0].coin[0].walletBalance)
//   );

// const accinfo = client
//   .getAccountInfo()
//   .then((response) => console.log("Accinfo", response));

// const linear = client
//   .getPositionInfo({
//     category: "linear",
//   })
//   .then((response) => console.log("linear", response.result));

// const inverse = client
//   .getActiveOrders({
//     category: "inverse",
//   })
//   .then((response) => console.log("inverse", response.result));

// const option = client
//   .getActiveOrders({
//     category: "option",
//   })
//   .then((response) => console.log("option", response.result.list));

// const res3 = client
//   .getPositionInfo({ category: "linear", settleCoin: "USDT" })
//   .then((response) => console.log("linear", response.result.list));

// const res4 = client
//   .getTickers({ category: "linear", symbol: "DOGEUSDT" })
//   .then((response) => console.log(response.result.list[0].lastPrice));

// const fff = client
//   .getWalletBalance({
//     accountType: "UNIFIED",
//     coin: "USDT",
//   })
//   .then((response) => console.log(response.result.list[0]));
