
const { RestClientV5 } = require("bybit-api"); // ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾
const { json } = require("express");
const WebSocket = require("ws");


class BybitService {
  _pool = new Map();

  orders = new Map();
  prices = {};
  symbols;
  promisePrices = new Map();

  wsTickers = new Set();
  ws;
// ÐšÐ¾Ð´ Ð´Ð»Ñ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ñ Ðº Ð²ÐµÐ±-ÑÐ¾ÐºÐµÑ‚Ð°Ð¼ Bybit
  async load() {
    this.ws = new WebSocket("wss://stream.bybit.com/v5/public/linear");
//Ð´Ð¾Ð¶Ð¸Ð´Ð°ÐµÐ¼ÑÑ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ ÑÐ¾ÐºÐµÑ‚Ð°

    await new Promise(
      (resolve)=>this.ws.on("open",()=>{
        console.log("Bybit: Public Websocket open");
        
        resolve();
    }));

    this.ws.onmessage = (event) => {

        const data = JSON.parse(event.data);//Ð´Ð°Ð½Ð½Ñ‹Ðµ, Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ðµ Ð² ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¸ Ð´ÐµÐ»Ð°ÐµÑ‚ Ð¾Ð±ÑŠÐµÐºÑ‚
        console.log("Ð”ÐÐ¢Ð", data)
        this.onWSData(data);
    };

   

    this.ws.onclose = async () => {
      console.info("Bybit: Connection closed.");

      await this.load();

      this.wsTickers.forEach((ticker) => {
        this.ws.send(
          JSON.stringify({ op: "unsubscribe", args: [`publicTrade.${ticker}`] })
        );
      });
    };

    this.ws.onerror = () => console.info("Bybit: Connection error.");
  }
// ÐšÐ¾Ð´ Ð´Ð»Ñ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸ Ð¿Ð¾Ð´Ð¿Ð¸ÑÐºÐ¸ Ð½Ð° Ñ‚Ð¾Ñ€Ð³Ð¸ Ð¿Ð¾ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð½Ð¾Ð¼Ñƒ Ñ‚Ð¸ÐºÐµÑ€Ñƒ
  listTicker(ticker) {
    if (this.wsTickers.has(ticker)) return;
    console.log("subscribe on",ticker);
    this.wsTickers.add(ticker);
    this.ws.send(
      JSON.stringify({ op: "subscribe", args: [`publicTrade.${ticker}`] })
    );
  }
// ÐšÐ¾Ð´ Ð´Ð»Ñ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾ Ñ‚Ð¾Ñ€Ð³Ð°Ñ…

  onWSData(data) {
    if (!data){ return console.log("onWSData Ð½ÐµÑ‚ Ð´Ð°Ñ‚Ñ‹!")};

      //console.log("----------------------------------ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ†ÐµÐ½Ñ‹----------------------------------------------------");
      
      let entries = Object.entries(data)
      let newEnt = entries[3];
      let ki = Object.values(newEnt);
      let objectDataWhereTickers = JSON.stringify(ki);


      let resprice = objectDataWhereTickers.substring(objectDataWhereTickers.lastIndexOf('"p":"')+5);
      let lastprice = resprice.split('"')[0];
      const price = parseFloat(lastprice);
      

      let restick = objectDataWhereTickers.substring(objectDataWhereTickers.lastIndexOf('"s":"')+5);
      let ticker = restick.split('"')[0]
      
      

      //console.log("ki",objectDataWhereTickers);

    if(price){this.onMarkPrice({ ticker, price })}
      
    }


 // ÐšÐ¾Ð´ Ð´Ð»Ñ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ° Ð½Ð° Ñ€Ð°Ð·Ð¼ÐµÑ‰ÐµÐ½Ð¸Ðµ Ð¾Ñ€Ð´ÐµÑ€Ð°

  async onOpenOrder(req, res) {
//Ð±Ð°Ð´Ð¸ Ð½Ð°ÑˆÐµÐ³Ð¾ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°
    const data = req.body;
    
//side - Ð¿Ð¾ÐºÑƒÐ¿ÐºÐ° Ð¸Ð»Ð¸ Ð¿Ñ€Ð¾Ð´Ð°Ð¶Ð°
//ticker - Ñ‚Ð¾Ñ€Ð³Ð¾Ð²Ð°Ñ Ð¿Ð°Ñ€Ð°
    const { ticker, takeProfits, stopLoss, side } = data;
    console.log("======================================ONOPENORDER========================================")
    console.log(`Side: ${side}`);
    this.listTicker(ticker);
   
    const clients = DatabaseService.all();//ÑÐ¿Ð¸ÑÐ¾Ðº ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð¾Ð²
    data.clients = new Set();//Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ

    

    
    let price = this.prices[ticker];//Ñ‚ÐµÐºÑƒÑ‰Ð°Ñ Ñ†ÐµÐ½Ð° Ñ‚Ð¾Ñ€Ð³Ð¾Ð²Ð¾Ð¹ Ð¿Ð°Ñ€Ñ‹
    console.log(price)
    if (typeof price !== "number") price = await this.getPrice(ticker);
    console.log(`Get price ${ticker}: ${price}`);


    for await (const e of Object.values(clients)) {
      //const e = clients[i];
      console.log(e);

      if (e.exchange !== 1 || !e.bybit || !e.trading) continue;

      const client = await this.createSocket(
        e.bybit.publicKey,
        e.bybit.privateKey,
        e.bybit.isInverse
      );

      console.log(`Get client: ${!!client}`);

      if (!client) continue;

      const positions = await client.getPositionInfo({
        symbol: `${ticker}`,
        category: "linear",
        settleCoin: "USDT",
      });
      console.log("positions-------", positions);
      console.log("positionsreslist-------", positions.result.list);
      let getpos = (!positions || !Array.isArray(positions));

      console.log(`Get positions : ${getpos}`);

      if (getpos) {
        continue;
      }
//Ð’ ÑÑ‚Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð²Ñ‹Ð·Ñ‹Ð²Ð°ÐµÑ‚ÑÑ Onmarkprice
//ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚ ÐµÑÑ‚ÑŒ Ð»Ð¸ ÑÑƒÐ¼Ð±Ð¾Ð»Ñ ÐµÑÐ»Ð¸ Ð½ÐµÑ‚ Ñ‚Ð¾ ÑÐ¾Ð·Ð´Ð°ÐµÑ‚ Ð½Ð¾Ð²ÑƒÑŽ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½ÑƒÑŽ Ð¸ Ð¿Ñ€Ð¸ÑÐ²Ð°Ð¸Ð²Ð°ÐµÑ‚ ÐµÐ¹ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð³ÐµÑ‚Ñ‚Ð¸ÐºÐµÑ€ÑÐ°
      // console.log("symbolsposle", this.symbols)
      // if (!this.symbols) {
      //   console.log("Ð½ÐµÑ‚ Ð¼Ð°ÑÑÐ¸Ð²Ð° symbols")

      //   this.symbols = await client.getTickers({
      //     category: "linear",
      //     settleCoin: "USDT",
      //   }).result.list;

      //   console.log("symbols", this.symbols)
      // }

      
      if (!e.maxPositions) {
        e.maxPositions = 5;
      }

      const activePositions = positions.reduce(
        (a, b) => a + (b.size !== 0 ? 1 : 0),
        0
      );

      console.log(
        `Is active positions max ${i}: ${activePositions >= e.maxPositions}`
      );

      if (activePositions >= e.maxPositions) {
        continue;
      }

      const balance = (await client.getWalletBalance({ coin: "USDT" })).result
        .USDT.available_balance;

      if (!e.capitalPercent) {
        e.capitalPercent = 5;
      }

      if (!e.leverage) {
        e.leverage = 15;
      }
      console.log("000000000000000000000000000000000000000000",typeof(this.symbols))
      const tickerData = this.symbols.find((e) => e.symbol === ticker);

      const price = tickerData.lastPrice;

      let quantity = parseFloat(
        (((balance * (e.capitalPercent / 100)) / price) * e.leverage).toFixed(
          tickerData.price_filter.tick_size.split(".")[1].length
        )
      );

      if (quantity < tickerData.lot_size_filter.min_trading_qty)
        quantity = tickerData.lot_size_filter.min_trading_qty;
      if (quantity > tickerData.lot_size_filter.max_trading_qty)
        quantity = tickerData.lot_size_filter.max_trading_qty;
      await this.closePosition(client, positions, ticker);

      const leverage = e.bybit.isInverse ? 1 / e.leverage : e.leverage; // Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¾

      const res = await client.submitOrder({
        side: side ? "Buy" : "Sell",
        category: "linear",
        symbol: ticker,
        orderType: "Market",
        qty: quantity,
        timeInForce: "FillOrKill",
        reduceOnly: false,
        closeOnTrigger: false,
        positionIdx: 0,
      });
//??????????????????????????????????????????????????????????????????????????????????????????
      console.log("Open position", res);

      data.clients.add([e.bybit.publicKey, e.bybit.privateKey, leverage]);

      await TelegramService.bot.sendMessage(
        parseInt(i),
        res && res.ret_code === 0
          ? `â˜‘ *NEW POSITION OPENED* â˜‘\nâ–ª *Ticker:* \`${
              data.ticker
            }\` \nâ–ª *Direction:* \`${
              data.side ? "Long" : "Short"
            }\`\nâ–ª *Entry:* \`${price}\`\nâ–ª *Amount:* \`${quantity} ${ticker.replace(
              "USDT",
              ""
            )}\`\nâž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–\nðŸ¤–The bot will *automatically open and close* this signal, please do not close this trade manually!`
          : `Some error when tried open ${data.ticker}`,
        {
          parse_mode: "markdown",
        }
      );
    }

    data.takeProfitsSize = data.takeProfits.length;
    data.entryPrice = price;

    this.orders.set(data.ticker, data);

    res.send("OK");
  }

  async onStopLossChange({ ticker, stopLoss }, res) {
    const order = this.orders.get(ticker);

    if (!order) return;

    order.stopLoss = stopLoss;

    this.orders.set(ticker, order);

    res.send("OK");
  }

  async onPositionExit({ ticker }, res) {
    const order = this.orders.get(ticker);

    if (!order) return res.send("ORDER DONT FOUND");

    let percentProfit = order.entryPrice / this.prices[ticker];

    if (percentProfit < 0) percentProfit = 1 - percentProfit + 1;

    for (const [publicKey, privateKey, leverage] of order.clients) {
      try {
        const client = await this.createSocket(publicKey, privateKey);
        const positions = (
          await client.getPositionInfo({
            category: "linear",
            settleCoin: "USDT",
          })
        ).result;

        if (!positions || !Array.isArray(positions)) {
          continue;
        }

        await this.closePosition(client, positions, ticker);

        const chatId = TelegramService.bybitPublicKeyId.get(publicKey);
        const profit = ((percentProfit - 1) * leverage * 100).toFixed(2);
        const dbData = DatabaseService.get(chatId);

        if (typeof dbData.pnl !== "number") {
          dbData.pnl = 0;
        }

        const profitPnl = Math.abs((percentProfit - 1) * leverage * 100);

        dbData.pnl += profitPnl;

        DatabaseService.set(chatId, dbData);

        await TelegramService.bot.sendMessage(
          chatId,
          `ðŸ’°*SIGNAL CLOSED*ðŸ’°\nâ–ª *Ticker*: \`${
            order.ticker
          }\`\nâ–ª *Direction*: ${
            order.side ? "Long" : "Short"
          }\nâž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–\nðŸ”¹ Targets reached: ${
            order.takeProfitsSize - order.takeProfits.length
          }\nðŸ”¹ Profit: +${profit}%`,
          {
            parse_mode: "markdown",
          }
        );
      } catch (e) {
        if (!e.message) e.message = e.body;

        console.log(
          `Some error when try exit position (Client: ${publicKey}): `,
          e.message
        );
      }
    }

    this.orders.delete(ticker);

    res.send("OK");
  }
//Ð½Ð¾Ð²Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ñ†ÐµÐ½Ñ‹ Ð´Ð»Ñ Ñ‚Ð¸ÐºÐµÑ€Ð°
  async onMarkPrice({ ticker, price }) {
    console.log("-------------------------------------------- ÐžÐ±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ†ÐµÐ½Ñ‹ Ð² ÑÐ¿Ð¸ÑÐºÐµ--------------------------------------------");
    console.log(`ticker: ${ticker} + price: ${price}`);
    //ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÐµÑÑ‚ÑŒ Ð»Ð¸ Ð¾Ð±ÐµÑ‰Ð°Ð½Ð¸Ñ Ð¿Ð¾ Ñ†ÐµÐ½Ðµ, ÐµÑÐ»Ð¸ ÐµÑÑ‚ÑŒ Ñ‚Ð¾ Ð¿ÐµÑ€ÐµÐ´Ð°ÐµÑ‚ÑÑ Ñ‚Ð¸ÐºÐµÑ€ Ð¸ Ð¿Ñ€Ð°Ð¹Ñ
    if (this.promisePrices.has(ticker)){this.promisePrices.get(ticker)(price)} ;
//Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ðµ Ñ†ÐµÐ½Ñ‹ Ð² ÑÐ¿Ð¸ÑÐºÐµ
    this.prices[ticker] = price;
    //console.log("prices",prices)
    const order = this.orders.get(ticker);
    console.log("order",order)
//ÐµÑÐ»Ð¸ Ð¾Ñ€Ð´ÐµÑ€Ð° Ð½ÐµÑ‚ Ñ‚Ð¾ Ð´Ñ€Ð¾Ð¿
    if (!order) return console.log("orderanet");
//Ð·Ð°Ð±Ð¸Ñ€Ð°ÐµÐ¼ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð´Ð»Ñ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð³Ð¾ Ñ‚Ð¸ÐºÐµÑ€Ð°

    if (!this.symbols) {
        console.log("Ð½ÐµÑ‚ Ð¼Ð°ÑÑÐ¸Ð²Ð° symbols")
        this.symbols = await client.getTickers({
          category: "linear",
          settleCoin: "USDT",
        });

        console.log("symbols", this.symbols)
      }

    console.log("syb",typeof(this.symbols))
    //const tickerData = this.symbols.find((e) => e.name === ticker);
    //console.log("!_!_!_!_!__!!_!_!_!",tickerData)

// "symbol":"1000000VINUUSDT","lastPrice":"0.015558","indexPrice":"0.015519","markPrice":"0.015525","prevPrice24h":"0.014410",
// "price24hPcnt":"0.079666","highPrice24h":"0.015558","lowPrice24h":"0.014171","prevPrice1h":"0.015357","openInterest":"3507100",
// "openInterestValue":"54447.73","turnover24h":"2333592.0814","volume24h":"159101900.0000","fundingRate":"0.00007872",
// "nextFundingTime":"1706428800000","predictedDeliveryPrice":"","basisRate":"","deliveryFeeRate":"","deliveryTime":"0","ask1Size":"887800",
// "bid1Price":"0.015461","ask1Price":"0.015558","bid1Size":"874400","basis":""

/*[{"symbol":"1000LUNCUSDT","leverage":"10","autoAddMargin":0,"avgPrice":"","liqPrice":"","riskLimitValue":"100000","takeProfit":"",
"positionValue":"","tpslMode":"","isReduceOnly":false,"riskId":1,"trailingStop":"","unrealisedPnl":"","markPrice":"","adlRankIndicator":0,
"cumRealisedPnl":"","positionMM":"","createdTime":"","positionIdx":0,"positionIM":"","seq":-1,"updatedTime":"","side":"","bustPrice":"",
"positionBalance":"","leverageSysUpdatedTime":"","size":"0","positionStatus":"","mmrSysUpdatedTime":"","stopLoss":"","tradeMode":0}]*/


    let takeProfitReached = false;
    let lastTakeProfit;
    let stopLoss = false;

    if (order.side && price <= order.stopLoss) {
      stopLoss = true;
    } else if (!order.side && price >= order.stopLoss) {
      stopLoss = true;
    }

    if (stopLoss) {
      this.orders.delete(ticker);
    } else {
      for (const take of order.takeProfits) {
        if (order.side && price >= take[0]) {
          takeProfitReached = true;
        }

        if (!order.side && price <= take[0]) {
          takeProfitReached = true;
        }

        if (takeProfitReached) {
          lastTakeProfit = take;
          order.takeProfits.splice(order.takeProfits.indexOf(take), 1);

          if (order.takeProfits.length === 0) {
            this.orders.delete(ticker);
          }

          break;
        }
      }
    }
//--------------------------------------------------------------------------------
    for (const [publicKey, privateKey, leverage] of order.clients) {
      if (takeProfitReached) {
        const chatId = TelegramService.bybitPublicKeyId.get(publicKey);
        let dbData = DatabaseService.get(chatId);

        if (!dbData.strategy) dbData.strategy = -1;

        if (
          dbData.strategy !== -1 &&
          dbData.strategy !== order.takeProfitsSize - order.takeProfits.length
        ) {
          continue;
        }

        const client = await this.createSocket(publicKey, privateKey);
        const position = await this.getActivePosition(client, ticker);

        if (position) {
          let quantity = position.data.size;

          let qty = quantity * (lastTakeProfit[1] / 100);

          qty = parseFloat(
            qty.toFixed(tickerData.price_filter.tick_size.split(".")[1].length)
          );

          const isFullPos =
            dbData.strategy !== -1 &&
            dbData.strategy ===
              order.takeProfitsSize - order.takeProfits.length;

          if (quantity < qty || order.takeProfits.length === 0 || isFullPos) {
            qty = quantity;
          }

          const result = await client.submitOrder({
            side: !order.side ? "Buy" : "Sell",
            symbol: ticker,
            order_type: "Market",
            qty,
            time_in_force: "FillOrKill",
            reduce_only: false,
            close_on_trigger: true,
            position_idx: 0,
          });

          console.log(
            "TAKEPROFIT CHATID" + chatId,
            order.takeProfitsSize - order.takeProfits.length,
            isFullPos,
            result
          );

          if (order.takeProfits.length === 0 || isFullPos) {
            let percentProfit = order.entryPrice / price;

            if (percentProfit < 0) percentProfit = 1 - percentProfit + 1;

            if (typeof dbData.pnl !== "number") {
              dbData.pnl = 0;
            }

            const profitPnl = Math.abs((percentProfit - 1) * leverage * 100);

            dbData.pnl += profitPnl;

            DatabaseService.set(chatId, dbData);

            await TelegramService.bot.sendMessage(
              chatId,
              `ðŸ’°*SIGNAL CLOSED*ðŸ’°\nâ–ª *Ticker*: \`${
                order.ticker
              }\`\nâ–ª *Direction*: ${
                order.side ? "Long" : "Short"
              }\nâž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–\nðŸ”¹ Targets reached: ${
                order.takeProfitsSize - order.takeProfits.length
              }\nðŸ”¹ Profit: +${profitPnl.toFixed(2)}%`,
              {
                parse_mode: "markdown",
              }
            );
          }
        }

        continue;
      }

      if (stopLoss) {
        const client = await this.createSocket(publicKey, privateKey);
        const position = await this.getActivePosition(client, ticker);

        if (position) {
          const result = await client.submitOrder({
            side: !order.side ? "Buy" : "Sell",
            symbol: ticker,
            order_type: "Market",
            qty: position.data.size,
            time_in_force: "FillOrKill",
            reduce_only: false,
            close_on_trigger: false,
            position_idx: 0,
          });

          let percentLoss = order.entryPrice / price;

          if (percentLoss < 0) percentLoss = 1 - percentLoss + 1;

          const chatId = TelegramService.bybitPublicKeyId.get(publicKey);
          let dbData = DatabaseService.get(chatId);

          if (typeof dbData.pnl !== "number") {
            dbData.pnl = 0;
          }

          if (order.takeProfitsSize - order.takeProfits.length < 2) {
            const profit = Math.abs((percentLoss - 1) * leverage * 100);

            dbData.pnl -= profit;

            await TelegramService.bot.sendMessage(
              chatId,
              `ðŸ©¸*STOP LOSS HIT*ðŸ©¸\nâ–ª *Ticker:* \`${
                order.ticker
              }\`\nâ–ª *Direction:* \`${
                order.side ? "Long" : "Short"
              }\`\nâž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–\nðŸ”»Loss: -${profit.toFixed(2)}%`,
              {
                parse_mode: "markdown",
              }
            );
          } else {
            const profit = Math.abs((percentLoss - 1) * leverage * 100);

            dbData.pnl += profit;

            await TelegramService.bot.sendMessage(
              chatId,
              `ðŸ’°*SIGNAL CLOSED*ðŸ’°\nâ–ª *Ticker*: \`${
                order.ticker
              }\`\nâ–ª *Direction*: ${
                order.side ? "Long" : "Short"
              }\nâž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–âž–\nðŸ”¹ Targets reached: ${
                order.takeProfitsSize - order.takeProfits.length
              }\nðŸ”¹ Profit: +${profit.toFixed(2)}%`,
              {
                parse_mode: "markdown",
              }
            );
          }

          DatabaseService.set(chatId, dbData);

          console.log("ByBit | StopLoss", result);
        }
      }
    }
  }

  async getActivePosition(client, ticker, positions = null) {
    if (!positions) {
      positions = (
        await client.getPositionInfo({
          symbol: `${ticker}`,
          category: "linear",
          settleCoin: "USDT",
        })
      ).result;

      if (!positions || !Array.isArray(positions)) {
        return null;
      }
    }

    const position = positions.find((e) => e.data.symbol === ticker);

    if (position) {
      const amt = position.data.size;

      if (typeof amt !== "number" || amt === 0) {
        return null;
      }

      return position;
    }

    return null;
  }

  async closePosition(client, positions, ticker) {
    const position = await this.getActivePosition(client, ticker, positions);

    if (!position) return;

    const result = await client.submitOrder({
      side: position.data.side === "Sell" ? "Buy" : "Sell",
      symbol: ticker,
      order_type: "Market",
      qty: position.data.size,
      time_in_force: "FillOrKill",
      reduce_only: false,
      close_on_trigger: false,
      position_idx: 0,
    });

    console.log("Close active position", result);
  }
//Ñ†ÐµÐ½Ð° ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ñ†ÐµÐ½Ñ‹ Ð°ÐºÑ‚Ð¸Ð²Ð° 
  async getPrice(ticker) {
    console.log("--------------------------------getPrice-----------------------------------------")
    const price = await new Promise((r) => {
      this.promisePrices.set(ticker, r);//ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ r Ð´Ð»Ñ ÐºÐ»ÑŽÑ‡Ð° Ñ‚Ð¸ÐºÐµÑ€
      console.log(price);
    });

    this.promisePrices.delete(ticker);

    return price;
  }

  async createSocket(key, secret, isInverse) {
    if (this._pool.has(key)) return this._pool.get(key);

    try {
      const client = new RestClientV5({
        key: key,
        secret: secret,
        // testnet
        testnet: true,

        enableTimeSync: true,
      });
      // testnet
      await client.getAccountInfo();

      this._pool.set(key, client);

      return client;
    } catch (e) {
      if (!e.message) e.message = e.body;
      console.log(e.message);
      return false;
    }
  }
//Ñ†ÐµÐ½Ð° Ñ‚Ð¸ÐºÐµÑ€Ð°
  async getTickerPrice(client, ticker) {
    return (await client.getTickers({ category: "linear", symbol: ticker }))
      .result.list[0].lastPrice;
  }
}

module.exports = new BybitService();

const client = new RestClientV5({
  key: "",
  secret: "",
  testnet: true,
  enableTimeSync: true,
});

const res4 = client
  .getTickers({category: "linear", settleCoin: "USDT" })
  .then((response) => console.log("Ð˜Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð¿Ð¾ Ð²ÑÐµÐ¼ Ñ‚Ð¸ÐºÐµÑ€Ð°Ð¼: ",response.result.list));

// const balance = client
//   .getWalletBalance({
//     accountType: "UNIFIED",
//     coin: "USDT",
//   })
//   .then((data) =>
//     console.log("Balacne ---", data.result.list[0].coin[0].walletBalance)
//   );

// const accinfo = client
//   .getAccountInfo()
//   .then((response) => console.log("Accinfo", response));

// const linear = client
//   .getPositionInfo({
//     category: "linear",
//   })
//   .then((response) => console.log("linear", response.result));

// const inverse = client
//   .getActiveOrders({
//     category: "inverse",
//   })
//   .then((response) => console.log("inverse", response.result));

// const option = client
//   .getActiveOrders({
//     category: "option",
//   })
//   .then((response) => console.log("option", response.result.list));

// const res3 = client
//   .getPositionInfo({ category: "linear", settleCoin: "USDT" })
//   .then((response) => console.log("linear", response.result.list));

// const res4 = client
//   .getTickers({ category: "linear", symbol: "DOGEUSDT" })
//   .then((response) => console.log(response.result.list[0].lastPrice));

// const fff = client
//   .getWalletBalance({
//     accountType: "UNIFIED",
//     coin: "USDT",
//   })
//   .then((response) => console.log(response.result.list[0]));
